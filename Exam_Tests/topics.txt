turing machine
traco computacional

dfa: atencao a ver se todos os input tem ligacao
dfa minimization: tabela, prova que duois automatos tem a mesma linguagem  
nfa - dfa : ttabela nfa ->tabel dfa
e-nfa - dfa: e-close, tabel e-nfa -.> tabela dfa
construcao de caminhos !! (Rn,n ^o = E+ ..)
eliminacao de estados
leis algebricas exp regulares
provar que nao e regular:: pumping lemma, closure proprites
propriedades de fecho das exp reg: (intersection, union, diference, closure, homormofism, concatenation, reverse, complement)
regulares expression - automato
automato - regular expression: eliminacao de estados


cgf: construcao
cnf form
propriedades de decisao
cnf - pda
pda vazio ou pda de estado de aceitacao
provar que nao e cfg: pumping lemma ou propriedades de fecho
propriedades de fecho das cfl: (intersection with rl, union, homormofism, concatenation, reverse, complement)
ambiguidade cfl (COMO O ALGORTIMO CFG->PDA leva a um pda nao determinista se a cfg for amigua entao apra ver se e ambigua basta passar para pda e ver se este e determinista)


Para o reverso, deve-se inverter a dire잒따o de todas as setas de transi잒딾es,
acrescentar um novo estado, que ser아 o estado inicial do novo au앒mato,
com transi잒딾es e para os estados de aceita잒따o do aut앒mato original (os
quais devem deixar de ser estados de aceita잒따o), e tornando o estado
inicial do aut앒mato original como 앗nico estado de aceita잒따o do novo
aut앒mato.

No caso da uni따o, os estados de aceita잒따o devem incluir os estados
de aceita잒따o tanto de um aut앒mato como de outro; para a interse잒따o, apenas
aqueles que incluam estados de aceita잒따o de ambos os aut앒matos originais;
para a diferen잒a, apenas os estados que sejam de aceita잒따o para o aut앒mato
da primeira linguagem mas n따o para o da segunda linguagem.
